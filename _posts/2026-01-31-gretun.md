---
layout: post
title: "gretun: GRE Tunnel Management CLI"
date: 2026-01-31
category: projects
---

Simple CLI for creating and managing GRE tunnels on Linux. Built for cloud VPC interconnection.

![GRE Tunnel Topology](/assets/images/projects/gretun-tunnel.png)

Organizations running multi-cloud or hybrid infrastructure need reliable ways to connect private networks across public internet boundaries. GRE tunnels provide kernel-native encapsulation for routing private IP traffic through public networks without the complexity of IPsec key exchange or the overhead of userspace VPN daemons. The approach works well for trusted networks like VPCs under your control, where the simplicity of stateless encapsulation outweighs the lack of built-in encryption.

The gretun CLI wraps Linux netlink operations into four commands that mirror the mental model of tunnel lifecycle management. Creating a tunnel requires specifying local and remote endpoints with public IPs, the tunnel interface IP from a private range, and an optional GRE key for basic filtering. The tool handles netlink message serialization, interface configuration, MTU calculation, and rollback on partial failures. No need to remember ip tunnel syntax variations or debug cryptic netlink errors when permissions are missing.

GRE encapsulation adds an outer IP header and GRE header to each packet. The outer header uses public IPs to route across the internet, the GRE header marks the payload as encapsulated using IP protocol 47, and the inner packet travels unchanged with its private IPs intact. At the remote endpoint, the Linux kernel strips the outer headers and delivers the inner packet to the tunnel interface. Applications see a standard network interface with private addressing. The kernel handles all encapsulation and decapsulation, which keeps overhead low compared to userspace processing.

## Netlink and MTU Challenges

Linux network configuration operates through netlink sockets rather than parsing command output or manipulating files. The vishvananda/netlink library provides a Go interface to these kernel APIs. Creating a tunnel involves four netlink operations in sequence: create a GRE link device with local and remote addresses, assign the tunnel IP to the interface, bring the interface up, and optionally add routes for remote subnets. Error handling requires care because partial failures leave interfaces in broken states. The CLI implements rollback by tracking which operations succeeded and unwinding them if subsequent steps fail.

Permissions caused immediate failures until I added an early check for CAP_NET_ADMIN. Netlink operations return opaque errors when capabilities are missing. Detecting this upfront and showing a clear message about running with sudo saves debugging time. The check happens before any netlink calls so users get actionable feedback immediately.

MTU calculation proved unexpectedly complex. GRE adds 24 bytes of overhead: 20 bytes for the outer IP header and 4 bytes for the GRE header. If the physical interface has a 1500-byte MTU, the tunnel can only carry 1476-byte inner packets without fragmentation. Packets larger than this get fragmented or dropped depending on the DF bit. The CLI calculates tunnel MTU automatically by querying the physical interface MTU and subtracting overhead. This prevents silent packet loss that would otherwise manifest as application timeouts on large transfers. MTU issues appear frequently in production networks but are easy to miss during basic testing.

Testing tunnel functionality without multiple physical machines required network namespaces. Linux namespaces create isolated network stacks on a single host. Two namespaces connected by veth pairs simulate separate machines. Creating GRE tunnels between namespaces exercises the full code path including encapsulation, routing, and decapsulation. This approach enabled comprehensive testing without deploying to actual cloud instances.

The CLI implements four commands covering the complete lifecycle. Create configures a new tunnel with local and remote public IPs, a tunnel interface IP from a private range, and an optional GRE key. List shows all active GRE tunnels with their configuration in human-readable or JSON format for scripting. Probe runs ICMP health checks to the remote tunnel IP with configurable timeout and retry thresholds. Delete tears down the tunnel interface and removes associated routes cleanly. The command structure maps directly to operational workflows: create tunnels between sites, verify connectivity, delete when reconfiguring.

Common use cases include site-to-site VPN for connecting on-premises networks to cloud VPCs, multi-cloud networking for linking AWS VPCs to GCP networks using each cloud's public IP endpoints, and lab environments where spinning up isolated test networks requires fast tunnel creation and teardown. GRE works particularly well for these scenarios because both endpoints are under your administrative control and traffic flows through private or dedicated circuits where the lack of encryption is acceptable.

Current limitations point toward natural next steps. The implementation supports only IPv4 for both outer and inner addresses. Adding IPv6 support would double the use cases by enabling IPv6-only clouds or dual-stack configurations. Health checks currently use ICMP pings, which verify tunnel reachability but not application-layer connectivity. Extending probe to support TCP handshakes or HTTP requests would catch more failure modes like firewall misconfigurations that block specific protocols while allowing ICMP.

Working on gretun taught me that network programming requires careful attention to state management and error recovery. Netlink operations can partially succeed, leaving the system in unexpected states. Rollback logic and clear error messages matter more than in typical CRUD applications. MTU issues are subtle but common in production. Testing with network namespaces provides a powerful alternative to multi-machine test environments for network tooling. These patterns apply broadly to any system-level networking code beyond just tunnel management.

---

[View on GitHub](https://github.com/HueCodes/gretun)
